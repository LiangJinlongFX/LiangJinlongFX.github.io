<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/facicon/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/assets/facicon/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="#FPGA介绍                     可编程逻辑器件是什么       &amp;#8195;&amp;#8195;在集成数字电路芯片中，除了电路逻辑固化的芯片, 还有一种可编程逻辑器件(PLD), 允许出厂后对其数字逻辑进行变更。早期的 PLD 发展出了 PAL （可编程阵列逻辑），但 PAL 只能写入一次逻辑配置，后来出现可重复烧录的 GAL (通用数组逻辑)。如今可编程器件发展主要分为 C">
<meta property="og:type" content="article">
<meta property="og:title" content="fpga_introduction">
<meta property="og:url" content="https://liangjinlongfx.github.io/2021/05/11/fpga-introduction/index.html">
<meta property="og:site_name" content="Jinlong&#39;s Blog">
<meta property="og:description" content="#FPGA介绍                     可编程逻辑器件是什么       &amp;#8195;&amp;#8195;在集成数字电路芯片中，除了电路逻辑固化的芯片, 还有一种可编程逻辑器件(PLD), 允许出厂后对其数字逻辑进行变更。早期的 PLD 发展出了 PAL （可编程阵列逻辑），但 PAL 只能写入一次逻辑配置，后来出现可重复烧录的 GAL (通用数组逻辑)。如今可编程器件发展主要分为 C">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-11T13:30:02.000Z">
<meta property="article:modified_time" content="2021-05-13T14:40:15.674Z">
<meta property="article:author" content="Jinlong">
<meta property="article:tag" content="1">
<meta name="twitter:card" content="summary"><title>fpga_introduction | Jinlong's Blog</title><link ref="canonical" href="https://liangjinlongfx.github.io/2021/05/11/fpga-introduction/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Jinlong's Blog</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">fpga_introduction</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-05-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-05-13</span></span></div></header><div class="post-body"><p>#FPGA介绍</p>

        <h2 id="可编程逻辑器件是什么"   >
          <a href="#可编程逻辑器件是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#可编程逻辑器件是什么" class="headerlink" title="可编程逻辑器件是什么"></a>可编程逻辑器件是什么</h2>
      <p>&#8195;&#8195;在集成数字电路芯片中，除了电路逻辑固化的芯片, 还有一种可编程逻辑器件(PLD), 允许出厂后对其数字逻辑进行变更。早期的 PLD 发展出了 PAL （可编程阵列逻辑），但 PAL 只能写入一次逻辑配置，后来出现可重复烧录的 GAL (通用数组逻辑)。如今可编程器件发展主要分为 CPLD 和 FPGA 两种类别。一颗CPLD内等于包含了数颗的PAL，各PAL（逻辑区块）间的互接连线也可以进行程序性的规划、刻录，CPLD运用这种多合一（All-In-One）的集成作法，使其一颗就能实现数千个逻辑门，甚至数十万个逻辑门才能构成的电路。各厂商CPLD芯片多具有焊接后再行传输、再次刻录的技术，但各家的技术实现方式与名称多不尽相同。FPGA运用一种逻辑门式的网格（Grid），这种网格与普通的“闸数组”相类似，网格可以在FPGA芯片出厂后才进行配置配置的程序性规划。FPGA通常也可以在焊接后再进行程序刻录、变更的工作，此在某种程度与大型的CPLD相似。而绝大多数的FPGA，其内部的程序配置配置是属于易失性的，即是无持续电力供应后逻辑配置的内容就会消失，所以在设备重新获得电力后，就必须将配置配置内容重新加载（re-load）到FPGA中，或者期望改变FPGA内的逻辑配置时，也必须进行重新加载的动作。</p>

        <h3 id="CPLD-与-FPGA-的区别"   >
          <a href="#CPLD-与-FPGA-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#CPLD-与-FPGA-的区别" class="headerlink" title="CPLD 与 FPGA 的区别"></a>CPLD 与 FPGA 的区别</h3>
      <ul>
<li>CPLD更适合完成各种算法和组合逻辑，FPGA更适合于完成时序逻辑。换句话说，FPGA更适合于触发器丰富的结构，而CPLD更适合于触发器有限而乘积项丰富的结构。</li>
<li>CPLD的连续式布线结构决定了它的时序延迟是均匀的和可预测的，而FPGA的分段式布线结构决定了其延迟的不可预测性</li>
<li>在编程上FPGA比CPLD具有更大的灵活性。CPLD通过修改具有固定内连电路的逻辑功能来编程，FPGA主要通过改变内部连线的布线来编程；FPGA可在逻辑门下编程，而CPLD是在逻辑块下编程，粗粒与细粒。</li>
<li>FPGA的集成度比CPLD高，具有更复杂的布线结构和逻辑实现</li>
<li>CPLD比FPGA使用起来更方便。CPLD的编程采用E2PROM或FASTFLASH技术，无需外部存储器芯片，使用简单。而FPGA的编程信息需存放在外部存储器上，使用方法复杂</li>
<li>CPLD的速度比FPGA快，并且具有较大的时间可预测性。这是由于FPGA是门级编程，并且CLB之间采用分布式互联，而CPLD是逻辑块级编程，并且其逻辑块之间的互联是集总式的。</li>
<li>在编程方式上，CPLD主要是基于E2PROM或FLASH存储器编程，编程次数可达1万次，优点是系统断电时编程信息也不丢失。CPLD又可分为在编程器上编程和在系统编程两类。FPGA大部分是基于SRAM编程，编程信息在系统断电时丢失，每次上电时，需从器件外部将编程数据重新写入SRAM中。其优点是可以编程任意次，可在工作中快速编程，从而实现板级和系统级的动态配置。</li>
<li>CPLD保密性好，FPGA保密性差</li>
<li>一般情况下，CPLD的功耗要比FPGA大，且集成度越高越明显</li>
</ul>

        <h3 id="专用集成电路"   >
          <a href="#专用集成电路" class="heading-link"><i class="fas fa-link"></i></a><a href="#专用集成电路" class="headerlink" title="专用集成电路"></a>专用集成电路</h3>
      <p>&#8195;&#8195;特殊应用集成电路是由特定使用者要求和特定电子系统的需要而设计、制造。由于单个专用集成电路芯片的生产成本很高，如果出货量较小，则采用专用集成电路在经济上不太实惠。这种情况可以使用可编程逻辑器件（如现场可编程逻辑门阵列）来作为目标硬件实现集成电路设计。此外，可编程逻辑器件具有用户可编程特性，因此适合于大规模芯片量产之前的原型机，来进行调试等工作。但是可编程逻辑器件在面积、速度方面的优化程度不如全定制的集成电路。</p>

        <h2 id="FPGA-的特性"   >
          <a href="#FPGA-的特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#FPGA-的特性" class="headerlink" title="FPGA 的特性"></a>FPGA 的特性</h2>
      <p>&#8195;&#8195;现场可编程门阵列 (field programmable gate array) ，简称 FPGA。FPGA一般来说比专用集成电路（ASIC）的速度要慢，无法完成更复杂的设计，并且会消耗更多的电能。但是，FPGA具有很多优点，比如可以快速成品，而且其内部逻辑可以被设计者反复修改，从而改正程序中的错误，此外，使用FPGA进行调试的成本较低。厂商也可能会提供便宜、但是编辑能力有限的FPGA产品。因为这些芯片有的可编辑能力较差，所以这些设计的开发是在普通的FPGA上完成的，然后将设计转移到一个类似于专用集成电路的芯片上。在一些技术更新比较快的行业，FPGA几乎是电子系统中的必要部件，因为在大批量供货前，必须迅速抢占市场，这时FPGA方便灵活的优势就显得很重要。</p>

        <h2 id="FPGA-的组成部分"   >
          <a href="#FPGA-的组成部分" class="heading-link"><i class="fas fa-link"></i></a><a href="#FPGA-的组成部分" class="headerlink" title="FPGA 的组成部分"></a>FPGA 的组成部分</h2>
      <ul>
<li><p>可编程逻辑块 (Configurable Logic Block, CLB)</p>
<p>  CLB是FPGA内部实现可编程逻辑的主要成分, 具体可参考[UltraScale Architecture  Configurable Logic Block](<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.xilinx.com/support/documentation/user_guides/ug574-ultrascale-clb.pdf" >UltraScale Architecture Configurable Logic Block User Guide (UG574) (xilinx.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>)。</p>
</li>
<li><p>Block Memory</p>
</li>
<li><p>物理 I/O</p>
</li>
<li><p>附件组件</p>
</li>
</ul>

        <h2 id="FPGA-与-CPU-DSP-GPU-比较"   >
          <a href="#FPGA-与-CPU-DSP-GPU-比较" class="heading-link"><i class="fas fa-link"></i></a><a href="#FPGA-与-CPU-DSP-GPU-比较" class="headerlink" title="FPGA 与 CPU/DSP/GPU 比较"></a>FPGA 与 CPU/DSP/GPU 比较</h2>
      <p>&#8195;&#8195;在硬件层面，DSP/CPU/GPU都是是ASIC，适宜于量产降低成本，缺点是（硬件）设计一旦确定，便不易于修改。处理架构固定。</p>
<p>&#8195;&#8195;与CPU等架构相比，构成FPGA架构的结构可在应用程序执行中实现高度并行性，也可以设计成特定的 CPU 架构验证平台。处理器（CPU）和FPGA之间的关键区别之一就是处理架构是否固定。CPU架构中应用程序执行只能适应流水线结构的处理流程，而在 FPGA 中，其相当于一个白板，可以根据实际需要设计成最适应的处理架构。但一般 FPGA 模拟对应的 CPU 等架构当然没有反复验证设计的专用 CPU ASIC 性能那么好。</p>

        <h2 id="EDA-的-FPGA-设计流程"   >
          <a href="#EDA-的-FPGA-设计流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#EDA-的-FPGA-设计流程" class="headerlink" title="EDA 的 FPGA 设计流程"></a>EDA 的 FPGA 设计流程</h2>
      
        <h3 id="1-设计输入"   >
          <a href="#1-设计输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-设计输入" class="headerlink" title="1.设计输入"></a>1.设计输入</h3>
      <p>​    分为原理图输入、HDL 文本输入以及波形输入等方式。</p>

        <h3 id="2-综合"   >
          <a href="#2-综合" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-综合" class="headerlink" title="2.综合"></a>2.综合</h3>
      <p>&#8195;&#8195;综合，就是针对给定的电路实现功能和实现此电路的约束条件，如速度、功耗、成本及电路类型等，通过计算机进行优化处理，获得一个能满足上述要求的电路设计方案。也就是是说，被综合的文件是HDL文件（或相应文件等），综合的依据是逻辑设计的描述和各种约束条件，综合的结果则是一个硬件电路的实现方案，该方案必须同时满足预期的功能和约束条件。对于综合来说，满足要求的方案可能有多个，综合器将产生一个最优的或接近最优的结果。因此，综合的过程也就是设计目标的优化过程，最后获得的结构与综合器的工作性能有关。</p>
<p>&#8195;&#8195;综合生成输出文件称为网表，网表中除了包含从HDL语言中infer（推断）出的与门、非门等组合逻辑和寄存器等时序逻辑之外，还包含FPGA特有的各种原语(Primitive)比如LUT，BRAM，DSP48（Xilinx），甚至PowerPC（Xilinx），PCIe等硬核模块，以及这些模块的属性和约束信息。网表的业界标准是EDIF格式。文件后缀通常为.edn, .edf, .edif。</p>

        <h3 id="3-适配"   >
          <a href="#3-适配" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-适配" class="headerlink" title="3.适配"></a>3.适配</h3>
      <p>&#8195;&#8195;适配的适配对象直接与器件的结构相对应。逻辑综合通过后必须利用适配器将综合后网表文件针对某一具体的目标器件进行逻辑映射操作，其中包括底层器件配置、逻辑分割、逻辑优化、逻辑布局布线操作。适配完成后可以利用适配所产生的仿真文件作精确的时序仿真，同时产生可应用于编程的文件。</p>

        <h3 id="4-时序仿真与功能仿真"   >
          <a href="#4-时序仿真与功能仿真" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-时序仿真与功能仿真" class="headerlink" title="4.时序仿真与功能仿真"></a>4.时序仿真与功能仿真</h3>
      <p>&#8195;&#8195;通常情况下，先进行功能仿真，因此功能仿真又称为前仿真，它直接对原理图描述或其他描述形式的逻辑功能进行测试模拟，验证其实现的功能是否满足原设计的要求，仿真的过程不涉及任何具体形式的硬件特性，不经历综合和适配。在功能仿真已经完成，确认设计文件表达的功能满足要求后，再进行综合适配和时序仿真。时序仿真是在选择了具体器件并且完成布局布线之后进行的时序关系仿真，因此又称为时延仿真或后仿真。</p>

        <h3 id="5-编程下载"   >
          <a href="#5-编程下载" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-编程下载" class="headerlink" title="5.编程下载"></a>5.编程下载</h3>
      <p>&#8195;&#8195;将设计处理中产生的编程数据下载到具体的可编程器件中。如果之前的步骤都满足设计的要求，就可以将适配器产生的配置或下载文件通过CPLD/FPGA编程器或下载电缆载入目标芯片CPLD或FPGA中。</p>

        <h3 id="6-硬件测试"   >
          <a href="#6-硬件测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-硬件测试" class="headerlink" title="6.硬件测试"></a>6.硬件测试</h3>
      <p>&#8195;&#8195;将含有载入了设计的FPGA或CPLD的硬件系统进行统一测试，便于在真实的环境中检验设计效果。</p>

        <h2 id="FPGA-设计一些术语"   >
          <a href="#FPGA-设计一些术语" class="heading-link"><i class="fas fa-link"></i></a><a href="#FPGA-设计一些术语" class="headerlink" title="FPGA 设计一些术语"></a>FPGA 设计一些术语</h2>
      
        <h3 id="BlackBox"   >
          <a href="#BlackBox" class="heading-link"><i class="fas fa-link"></i></a><a href="#BlackBox" class="headerlink" title="BlackBox"></a>BlackBox</h3>
      <p>&#8195;&#8195;一个大的设计中可以用到一系列网表文件作为输入的一部分而并不全部使用HDL文件。当综合这个大设计时综合器不需要知道这个网表文件是怎样实现的，而只需要知道它的输入输出接口就可以了。这样的网表就称为黑盒子，因为我们不需要看到它的内部情况。通常付费IP都会以BlackBox的形式。</p>
<p>&#8195;&#8195;每个BlackBox网表都需要有一个与之相对应的HDL文件来注明它的端口。这个HDL只说明BlackBox的端口信息，而不提供具体实现信息。这个只提供端口信息的HDL文件称为Wrapper。Wrapper的名字通常需要与BlackBox网表的名字相同</p>

        <h3 id="IP-核"   >
          <a href="#IP-核" class="heading-link"><i class="fas fa-link"></i></a><a href="#IP-核" class="headerlink" title="IP 核"></a>IP 核</h3>
      <p>&#8195;&#8195;IP (Intellligent Property) 核是具有知识产权的集成电路芯核总称。是经过反复验证具有特定功能的逻辑宏模块，与芯片制造工艺无关，可以移植到不同的半导体工艺中。IP 核设计已经成为 ASIC 电路设计公司和 FPGA 供应商的重要任务，也是其实力的体现。目前，IP 核已经成为系统设计的基本单元，并作为独立设计成果被交换、转让以及销售。</p>
<p>&#8195;&#8195;从 IP 核的提供方式上，通常分为软核、硬核以及固核三类。</p>

        <h4 id="软核-Soft-IP-Core"   >
          <a href="#软核-Soft-IP-Core" class="heading-link"><i class="fas fa-link"></i></a><a href="#软核-Soft-IP-Core" class="headerlink" title="软核 (Soft IP Core)"></a>软核 (Soft IP Core)</h4>
      <p>&#8195;&#8195;软核指的是综合之前的寄存器传输级模型 (RTL)。具体在 FPGA 设计中指的是对逻辑电路的硬件语言描述，包括逻辑描述、网表和帮助文档等。其优点在于灵活性高、可移植性强，允许用户自配置。缺点是在后续设计中存在发生错误的风险。软核是应用最广泛的方式。</p>

        <h4 id="固核-Firm-IP-Core"   >
          <a href="#固核-Firm-IP-Core" class="heading-link"><i class="fas fa-link"></i></a><a href="#固核-Firm-IP-Core" class="headerlink" title="固核 (Firm IP Core)"></a>固核 (Firm IP Core)</h4>
      <p>&#8195;&#8195;固核指的是带有平面规划信息的网表。在 FPGA 设计中可以看成带有布局规划的软核，通常以 RTL 代码以及对应具体工艺网表的混合形式提供。和软核相比其灵活性稍差但可靠性有较大提高。</p>

        <h4 id="硬核-Hard-IP-Core"   >
          <a href="#硬核-Hard-IP-Core" class="heading-link"><i class="fas fa-link"></i></a><a href="#硬核-Hard-IP-Core" class="headerlink" title="硬核 (Hard IP Core)"></a>硬核 (Hard IP Core)</h4>
      <p>&#8195;&#8195;硬核指的是经过验证的设计版图。具体在 FPGA 设计中指的是布局和工艺固定、经过前后端验证的设计，开发人员不能对其修改。因此适用范围较窄。</p>

        <h3 id="Soc-FPGA"   >
          <a href="#Soc-FPGA" class="heading-link"><i class="fas fa-link"></i></a><a href="#Soc-FPGA" class="headerlink" title="Soc FPGA"></a>Soc FPGA</h3>
      <p>&#8195;&#8195;SoC FPGA为一个整合FPGA架构逻辑资源、硬式核心CPU子系统以及其他硬式核心IP的半导体元件，可实现低延时频宽互联，并提高IP重用性；为系统设计人员提供更多的选择。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://liangjinlongfx.github.io">Jinlong</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://liangjinlongfx.github.io/2021/05/11/fpga-introduction/">https://liangjinlongfx.github.io/2021/05/11/fpga-introduction/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://liangjinlongfx.github.io/tags/1/">1</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/05/13/mcu_soc/soc-mcu-mpu-cpu-sip/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">如何理解soc/mcu/mpu/cpu/sip/模组</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/05/10/mcu_soc/mcu-interrupt/"><span class="paginator-prev__text">mcu_interrupt</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E5%99%A8%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">
          可编程逻辑器件是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPLD-%E4%B8%8E-FPGA-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">
          CPLD 与 FPGA 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF"><span class="toc-text">
          专用集成电路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FPGA-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">
          FPGA 的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FPGA-%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">
          FPGA 的组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FPGA-%E4%B8%8E-CPU-DSP-GPU-%E6%AF%94%E8%BE%83"><span class="toc-text">
          FPGA 与 CPU&#x2F;DSP&#x2F;GPU 比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EDA-%E7%9A%84-FPGA-%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">
          EDA 的 FPGA 设计流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E8%BE%93%E5%85%A5"><span class="toc-text">
          1.设计输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%BC%E5%90%88"><span class="toc-text">
          2.综合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%82%E9%85%8D"><span class="toc-text">
          3.适配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%97%B6%E5%BA%8F%E4%BB%BF%E7%9C%9F%E4%B8%8E%E5%8A%9F%E8%83%BD%E4%BB%BF%E7%9C%9F"><span class="toc-text">
          4.时序仿真与功能仿真</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BC%96%E7%A8%8B%E4%B8%8B%E8%BD%BD"><span class="toc-text">
          5.编程下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%A1%AC%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">
          6.硬件测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FPGA-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD"><span class="toc-text">
          FPGA 设计一些术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BlackBox"><span class="toc-text">
          BlackBox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E6%A0%B8"><span class="toc-text">
          IP 核</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E6%A0%B8-Soft-IP-Core"><span class="toc-text">
          软核 (Soft IP Core)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E6%A0%B8-Firm-IP-Core"><span class="toc-text">
          固核 (Firm IP Core)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E6%A0%B8-Hard-IP-Core"><span class="toc-text">
          硬核 (Hard IP Core)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Soc-FPGA"><span class="toc-text">
          Soc FPGA</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/images/author_image.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/LiangJinlongFX" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/Jinlong15071708" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">归档</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Jinlong</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>