<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/facicon/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/assets/facicon/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Jinlong&#39;s Blog">
<meta property="og:url" content="https://liangjinlongfx.github.io/index.html">
<meta property="og:site_name" content="Jinlong&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jinlong">
<meta name="twitter:card" content="summary"><title>Jinlong's Blog</title><link ref="canonical" href="https://liangjinlongfx.github.io/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Jinlong's Blog</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/01/19/mcu_soc/DDR-SRAM/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>DDR-SRAM</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/12/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-12-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-30</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>根据应用场合对计算机分类：</p>
<ul>
<li><p>General Purpose (PC and Server)</p>
<p>  高性能</p>
</li>
<li><p>Embedded</p>
<p>  低功耗</p>
</li>
</ul>
<p>硬件：逻辑开关 -&gt; 逻辑门 -&gt; 逻辑电路</p>
<p>软件：高级语言 -&gt; 汇编语言 -&gt; 机器码</p>

        <h2 id="性能测量"   >
          <a href="#性能测量" class="heading-link"><i class="fas fa-link"></i></a><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h2>
      <p>每指令周期 (CPI) 指标是完成一个指令所需的处理器周期数</p>
<p>机器周期 = CPU 周期，表示 CPU 的心跳，某指令执行时间 (CPU Time) = N x 机器周期</p>
<p>CPU 执行时间 = 指令数 x CPI</p>
<p>CMOS IC 功耗规律：电压越高，功耗越高；频率越高，功耗越高；面积越大，功耗越大，目前向着多核方面发展</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/06/03/mcu_soc/mcu-sdk/">BSP、SDK是什么</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-06-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="BSP"   >
          <a href="#BSP" class="heading-link"><i class="fas fa-link"></i></a><a href="#BSP" class="headerlink" title="BSP"></a>BSP</h2>
      <p>&#8195;&#8195;BSP 即 <em>Board Support Package</em>，板级支持包。它来源于嵌入式操作系统与硬件无关的设计思想，操作系统被设计为运行在虚拟的硬件平台上。对于具体的硬件平台，与硬件相关的代码都被封装在<em>BSP</em>中，由 BSP 向上提供虚拟的硬件平台，<em>BSP</em>与操作系统通过定义好的接口进行交互。BSP 是所有与硬件相关的代码体的集合。一个成熟的商用操作系统，其被广泛应用的必要条件之一就是能够支持众多的硬件平台，并实现应用程序的硬件无关性。一般来说，这种无关性都是由操作系统实现的。但对于嵌入式系统来说，它没有像 PC 机那样具有广泛使用的各种工业标准、统一的硬件结构。各种嵌入式系统各不同的应用需求就决定了它一般都选用各自定制的硬件环境，每种嵌入式系统从核心的处理器到外部芯片在硬件结构上都有很大的不同。这种诸多变化的硬件环境就决定了无法完全由操作系统来实现上层软件与底层硬件之间的无关性。因此各种商用实时操作系统，都采用了分层设计的方法，它将系统中与硬件直接相关的一层软件独立出来，称之为 Board Support Package，简称为 BSP。顾名思义，<em>BSP</em>是针对某个特定的单板而设计的。如果没有单板支持软件包，则操作系统就不能在单板上运行。并且它对于用户（指开发者）也是开放的，用户可以根据不同的硬件需求对其作改动或二次开发。</p>
<p>&#8195;&#8195;对于运行 Linux 系统的 SOC，SOC 厂商都会提供基于 SOC 评估板以用于 uboot 以及 linux 内核的 BSP。而对于 MCU 运行 RTOS. 更多的是需要开发者根据 MCU 开发包基于实际硬件情况去开发自己的 BSP。</p>

        <h2 id="SDK"   >
          <a href="#SDK" class="heading-link"><i class="fas fa-link"></i></a><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2>
      <p>&#8195;&#8195;芯片制造商针对 MCU 的软件开发一般会提供一些源码以及工具等资源的开发包。注意该 SDK 定义仅是针对于 MCU 嵌入式软件开发领域的定义</p>

        <h3 id="MCU开发包SDK内容"   >
          <a href="#MCU开发包SDK内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#MCU开发包SDK内容" class="headerlink" title="MCU开发包SDK内容"></a>MCU开发包SDK内容</h3>
      
        <h4 id="芯片内核相关源码"   >
          <a href="#芯片内核相关源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#芯片内核相关源码" class="headerlink" title="芯片内核相关源码"></a>芯片内核相关源码</h4>
      <p>&#8195;&#8195;如 Cortex-M 内核的 MCU，一般会提供 CMSIS 组件包，对内核的软件编程都是基于 CMSIS 进行开发的，同时也会提供基于该芯片的内核启动汇编代码文件</p>

        <h4 id="芯片外设的相关源码"   >
          <a href="#芯片外设的相关源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#芯片外设的相关源码" class="headerlink" title="芯片外设的相关源码"></a>芯片外设的相关源码</h4>
      <p>&#8195;&#8195;提供外设访问的相关软件接口源码</p>

        <h4 id="BSP-模板工程代码"   >
          <a href="#BSP-模板工程代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#BSP-模板工程代码" class="headerlink" title="BSP 模板工程代码"></a>BSP 模板工程代码</h4>
      <p>&#8195;&#8195;提供 Keil/IAP/Eclipse 等IDE示例工程</p>

        <h4 id="板载外设的相关源码"   >
          <a href="#板载外设的相关源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#板载外设的相关源码" class="headerlink" title="板载外设的相关源码"></a>板载外设的相关源码</h4>
      <p>&#8195;&#8195;一般提供针对评估板载外设的驱动代码</p>

        <h4 id="评估板的示例代码"   >
          <a href="#评估板的示例代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#评估板的示例代码" class="headerlink" title="评估板的示例代码"></a>评估板的示例代码</h4>
      <p>&#8195;&#8195;提供基于此款或者此系列 MCU 评估板的 BSP 示例代码</p>

        <h4 id="中间层库"   >
          <a href="#中间层库" class="heading-link"><i class="fas fa-link"></i></a><a href="#中间层库" class="headerlink" title="中间层库"></a>中间层库</h4>
      <p>&#8195;&#8195;一般提供 FreeRTOS、FatFs、USB Stack 等开源代码</p>

        <h4 id="文档"   >
          <a href="#文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#文档" class="headerlink" title="文档"></a>文档</h4>
      <p>​    &#8195;&#8195;驱动代码使用指南以及API参考等</p>

        <h4 id="配置工具"   >
          <a href="#配置工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置工具" class="headerlink" title="配置工具"></a>配置工具</h4>
      <ul>
<li>时钟树配置</li>
<li>外设配置</li>
<li>引脚功能配置</li>
<li>自定义配置的 IDE 工程生成</li>
</ul>

        <h3 id="NXP-MCUXpresso-SDK"   >
          <a href="#NXP-MCUXpresso-SDK" class="heading-link"><i class="fas fa-link"></i></a><a href="#NXP-MCUXpresso-SDK" class="headerlink" title="NXP MCUXpresso SDK"></a>NXP MCUXpresso SDK</h3>
      <p>​    MCUXpress Software Development Kit (SDK)  提供了 NXP 旗下 Kinetis 以及 LPC 系列 MCU 的 板级支持包，其相关资源图示如下：</p>
<p><img src="https://raw.githubusercontent.com/LiangJinlongFX/gallery/main/MCUXpresso_Layer.PNG" alt="MCUXpresso_Layer"></p>
<p>&#8195;&#8195;相关的资源可以在 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://mcuxpresso.nxp.com/en/welcome" >Welcome | MCUXpresso SDK Builder (nxp.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 下载</p>

        <h4 id="支持的-IDE-以及交叉编译工具链"   >
          <a href="#支持的-IDE-以及交叉编译工具链" class="heading-link"><i class="fas fa-link"></i></a><a href="#支持的-IDE-以及交叉编译工具链" class="headerlink" title="支持的 IDE 以及交叉编译工具链"></a>支持的 IDE 以及交叉编译工具链</h4>
      <ul>
<li><p>keil</p>
<p>  提供 MCUXpresso SDK 源码的 Pack</p>
</li>
<li><p>IAR</p>
</li>
<li><p>MCUPresso</p>
<p>  NXP 基于 eclipse 开发的 IDE</p>
</li>
<li><p>ARM CC</p>
</li>
<li><p>ARM-GCC</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/05/24/mcu_soc/mcu-pwr-rcc/">电源、时钟、复位管理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-05-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-08-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="电源管理"   >
          <a href="#电源管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h2>
      
        <h3 id="电源引脚"   >
          <a href="#电源引脚" class="heading-link"><i class="fas fa-link"></i></a><a href="#电源引脚" class="headerlink" title="电源引脚"></a>电源引脚</h3>
      
        <h4 id="SOC-外部为什么有多组-VDD-VSS"   >
          <a href="#SOC-外部为什么有多组-VDD-VSS" class="heading-link"><i class="fas fa-link"></i></a><a href="#SOC-外部为什么有多组-VDD-VSS" class="headerlink" title="SOC 外部为什么有多组 VDD/VSS"></a>SOC 外部为什么有多组 VDD/VSS</h4>
      <p>&#8195;&#8195;原因主要有以下几点：</p>
<ol>
<li><p>芯片内部有很多功能单元，这些单元都需要供电，采用多引脚供电可以就近获取电源，无需在内部穿越。</p>
</li>
<li><p>存在多个电源域，不同单元之间，有时不希望电源互相影响，采用独立的电源引脚，可以避免这种影响。所以，<strong>多组VDD之间可能不连通</strong></p>
</li>
<li><p>实际使用时，每个引脚不但要连接电源，还应在电源引脚附近加上退藕电容。其目的是当器件工作时，电流的变化会引起电源的电压微小波动，加上退藕电容后，这种波动就不容易传递到另外的电源引脚。</p>
<p> 在电路设计中对供电引脚需要考虑几点：</p>
</li>
</ol>
<ul>
<li>尽管所有VDD和所有VSS在内部相连，在芯片外部仍然需要连接上所有的VDD和VSS。因为导线较细，内部连接负载能力较差，抗干扰的能力也较差，如果漏接VDD或VSS，容易造成内部线路损坏，同时抗干扰能力下降</li>
<li>每对VDD与VSS都必须在尽可能靠近芯片处放置滤波电容</li>
</ul>

        <h4 id="VDD-VDDA-VDDIO"   >
          <a href="#VDD-VDDA-VDDIO" class="heading-link"><i class="fas fa-link"></i></a><a href="#VDD-VDDA-VDDIO" class="headerlink" title="VDD / VDDA /VDDIO"></a>VDD / VDDA /VDDIO</h4>
      <p>&#8195;&#8195;VDD 表示主电源、VDDA 为模拟部分供电电源，而 VDDIO 则是 GPIO 供电电源。一些芯片将这三类电源分别用单独电源引脚引出，但其一般共用一个电源，电源之间压差有具体要求，具体参考 datasheet，也有芯片直接整合为一种类型的 VDD 引脚。</p>

        <h4 id="内部-LDO"   >
          <a href="#内部-LDO" class="heading-link"><i class="fas fa-link"></i></a><a href="#内部-LDO" class="headerlink" title="内部 LDO"></a>内部 LDO</h4>
      <p>&#8195;&#8195;一些专用芯片如车用芯片，内置高压 LDO，可用于只有单一高压电源的系统，因此不需要为其生成额外的电源，以减少外部电源器件使用以及提高稳定性，内部 LDO 可能需要外接 R/C 等辅助器件。当然除了使用内置高压 LDO，也可允许用户使用正常的 VDD.</p>
<p>&#8195;&#8195;一些低功耗芯片也有内置低电压的 LDO，以满足特殊需求。</p>

        <h3 id="电源域"   >
          <a href="#电源域" class="heading-link"><i class="fas fa-link"></i></a><a href="#电源域" class="headerlink" title="电源域"></a>电源域</h3>
      <p>&#8195;&#8195;为满足 SOC 不同工作模式的功耗等要求，通常将内部电源控制划分不同的区域，以根据实际需求细分电源供应区域。不同电源域之间电压不一定相同，同时支持根据实际功耗要求允许通过配置寄存器方式开闭相应外设的电源。</p>
<p>&#8195;&#8195;下图展示stm32f0x电源电源域</p>
<p><img src="https://img-blog.csdn.net/20180406104641136" alt="img"></p>

        <h3 id="电源监视器"   >
          <a href="#电源监视器" class="heading-link"><i class="fas fa-link"></i></a><a href="#电源监视器" class="headerlink" title="电源监视器"></a>电源监视器</h3>
      <p>&#8195;&#8195;电源监视器当检测到器件供电电压发生变化时产生复位等动作，常见的有：</p>
<ul>
<li><p>上电复位 (POR) 和 掉电复位 (PDR)</p>
<p>  当 VDD/VDDA 低于指定阈值 VPOR/PDR 时，器件无需外部复位电路便会保持复位状态。有关上电/掉电复位阈值的相关详细信息，请参见数据手册的电气特性部分</p>
</li>
<li><p>欠压复位 (PDR)</p>
<p>  上电期间，欠压复位 (BOR) 将使器件保持复位状态，直到电源电压达到指定的 VBOR 阈值，VBOR 阈值高于 VPOR/PDR，其阈值允许用户配置</p>
</li>
<li><p>可编程电压检测器 (PVD)</p>
<p>  指示 VDD 是大于还是小于 PVD 阈值，并产生相应的中断事件，该功能的用处之一就是可以在中断服务程序中执行紧急关闭系统的任务。</p>
</li>
</ul>

        <h2 id="时钟配置"   >
          <a href="#时钟配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#时钟配置" class="headerlink" title="时钟配置"></a>时钟配置</h2>
      
        <h3 id="时钟源"   >
          <a href="#时钟源" class="heading-link"><i class="fas fa-link"></i></a><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h3>
      <p>&#8195;&#8195;一般 MCU 时钟源分为内部以及外部两大类型，同时根据时钟快慢又细分为高速时钟以及低速时钟两类，即 HSE、LSE、HSI、LSI. 还有一些用于特定外设的固定时钟源。外部高速时钟一般为 MHz 单位为主要的时钟源，而外部低速时钟一般为 32.768 kHz，用于 RTC、WDT 等提供时钟源。外部时钟一般为无源晶振或者时钟信号输入，而内部时钟源一般为 RC 振荡器，其震荡频率精度不高且频率较低。具体器件应查看 datasheet 确定其时钟源有哪些</p>

        <h3 id="时钟树"   >
          <a href="#时钟树" class="heading-link"><i class="fas fa-link"></i></a><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h3>
      <p>&#8195;&#8195;时钟源出来的时钟并不直接时钟，一般需要经过分频以及倍频的处理以分别提供给内核、总线、外设等组件。时钟配置一般以树状结构方式以可视化配置，一般 MCU 内部存在多个 PLL 以及 分频器以配置合适的时钟，一般时钟类型分为：</p>
<ul>
<li>系统核心时钟</li>
<li>总线时钟</li>
<li>外设时钟（按需使能以降低功耗）</li>
</ul>

        <h2 id="复位管理"   >
          <a href="#复位管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#复位管理" class="headerlink" title="复位管理"></a>复位管理</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/05/23/linux/clash/">clash</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-05-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Ubuntu-安装-Clash"   >
          <a href="#Ubuntu-安装-Clash" class="heading-link"><i class="fas fa-link"></i></a><a href="#Ubuntu-安装-Clash" class="headerlink" title="Ubuntu 安装 Clash"></a>Ubuntu 安装 Clash</h1>
      
        <h2 id="安装以及配置"   >
          <a href="#安装以及配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装以及配置" class="headerlink" title="安装以及配置"></a>安装以及配置</h2>
      <p>从 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/Dreamacro/clash" >GitHub - Dreamacro/clash: A rule-based tunnel in Go.</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 下载对应平台的安装包。</p>
<p>解压缩安装包并将 clash-linux-amd64 文件重命名为 clash 设置可执行属性，然后拷贝到 /usr/bin 目录</p>
<p>首次执行 clash，会在 ~/.config/clash 目录生成默认的 config.yaml</p>
<p>关闭 clash，将 config.yaml 替换为自己的代理配置文件，如从 clash for windows 拷贝并替换自己的代理配置</p>
<p>重新执行clash，打印当前代理的端口，打开 ubuntu 网络设置，设置代理</p>
<p><img src="https://raw.githubusercontent.com/LiangJinlongFX/gallery/main/agent.jpg" alt="agent"></p>
<p>配置系统网络代理后，就可以翻墙了</p>

        <h2 id="禁用代理"   >
          <a href="#禁用代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#禁用代理" class="headerlink" title="禁用代理"></a>禁用代理</h2>
      <p>如果不使用代理，则禁用系统网络代理并关闭 clash 进程，如果 clash 关闭而没有禁用代理的话，系统则无法正常上网</p>

        <h2 id="clash-代理设置"   >
          <a href="#clash-代理设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#clash-代理设置" class="headerlink" title="clash 代理设置"></a>clash 代理设置</h2>
      <p>通过浏览器访问 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://clash.razord.top/#/proxies" >http://clash.razord.top/#/proxies</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 进行设置 </p>

        <h2 id="参考链接"   >
          <a href="#参考链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.shuzhiduo.com/A/kvJ3Nwq9zg/" >Linux Ubuntu18.04 安装配置 clash (shuzhiduo.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/05/23/mcu_soc/mcu-dma/">mcu-dma</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-05-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-08</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="MCU-DMA-控制器"   >
          <a href="#MCU-DMA-控制器" class="heading-link"><i class="fas fa-link"></i></a><a href="#MCU-DMA-控制器" class="headerlink" title="MCU DMA 控制器"></a>MCU DMA 控制器</h1>
      <p>&#8195;&#8195;DMA，全称Direct Memory Access，即直接存储器访问。DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实现和完成的。DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场过程，通过硬件为RAM和IO设备开辟一条直接传输数据的通道，使得CPU的效率大大提高。</p>

        <h2 id="DMA-控制器（STM32）"   >
          <a href="#DMA-控制器（STM32）" class="heading-link"><i class="fas fa-link"></i></a><a href="#DMA-控制器（STM32）" class="headerlink" title="DMA 控制器（STM32）"></a>DMA 控制器（STM32）</h2>
      <ul>
<li>双 AHB 主总线架构，一个用于存储器访问，另一个用于外设访问</li>
<li>DMA 控制器有 8 个数据流，每个数据流有多达 8 个通道（或称请求）</li>
<li>每个数据流有单独的四级 32 位先进先出存储器缓冲区 (FIFO)，可用于 FIFO 模式或直<br>  接模式<ul>
<li>FIFO 模式：可通过软件将阈值级别选取为 FIFO 大小的 1/4、1/2 或 3/4，数据缓存到 FIFO</li>
<li>直接模式：每个 DMA 请求会立即启动对存储器的传输</li>
</ul>
</li>
<li>DMA 数据流请求之间的优先级可用软件编程（4 个级别：非常高、高、中、低），在软<br>  件优先级相同的情况下可以通过硬件决定优先级（例如，请求 0 的优先级高于请求 1）</li>
<li>要传输的数据项的数目可以由 DMA 控制器或外设管理</li>
<li>独立的源和目标传输宽度（字节、半字、字）：源和目标的数据宽度不相等时，DMA 自动<br>  封装/解封必要的传输数据来优化带宽</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/05/23/mcu_soc/%E5%86%85%E9%83%A8%E6%80%BB%E7%BA%BF%E4%B8%8E%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/">内部总线与内存空间</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-05-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-07-06</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>内部总线与内存空间</p>

        <h1 id="总线与地址空间"   >
          <a href="#总线与地址空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#总线与地址空间" class="headerlink" title="总线与地址空间"></a>总线与地址空间</h1>
      <p>这里讨论的总线为内核直接访问的高速总线等片内总线，在了解计算机组成原理后，我们知道内核与外部交互最基本的是取指令以及访问数据，其结构有冯.诺曼、哈佛架构以及改进型的哈佛架构。</p>

        <h2 id="以-CY7C68013-为例的哈佛型架构"   >
          <a href="#以-CY7C68013-为例的哈佛型架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#以-CY7C68013-为例的哈佛型架构" class="headerlink" title="以 CY7C68013 为例的哈佛型架构"></a>以 CY7C68013 为例的哈佛型架构</h2>
      <p>哈佛架构的内核取指令与取数据分别用不同的总线访问寄存器，因此其访问地址空间是相互独立的，</p>
<p>500mg * 10ml = 40mg</p>
<p>2/25</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/05/21/mcu_soc/mcu-comm-ports/">MCU常见的通信外设</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-05-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-08-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="IIC"   >
          <a href="#IIC" class="heading-link"><i class="fas fa-link"></i></a><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h2>
      
        <h3 id="常见-IIC-接口特性"   >
          <a href="#常见-IIC-接口特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见-IIC-接口特性" class="headerlink" title="常见 IIC 接口特性"></a>常见 IIC 接口特性</h3>
      <ul>
<li>既可用作主模式也可用作从模式</li>
<li>IIC 主模式特性：时钟生成以及起始位和停止位生成</li>
<li>IIC 从模式特性：可编程 I2C 地址检测、对特定的从地址应答、地址位数设置，停止位检测</li>
<li>支持 SMBus</li>
<li>可选的应答位响应以及发送</li>
<li>相关的状态标志以及中断事件</li>
<li>DMA收发</li>
</ul>

        <h2 id="USART-通用同步异步收发器"   >
          <a href="#USART-通用同步异步收发器" class="heading-link"><i class="fas fa-link"></i></a><a href="#USART-通用同步异步收发器" class="headerlink" title="USART 通用同步异步收发器"></a>USART 通用同步异步收发器</h2>
      
        <h3 id="常见-USART-接口特性"   >
          <a href="#常见-USART-接口特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见-USART-接口特性" class="headerlink" title="常见 USART 接口特性"></a>常见 USART 接口特性</h3>
      <ul>
<li>支持全双工的异步通信</li>
<li>支持半双工的同步通信</li>
<li>数据帧位数可配置，停止位数可配置、奇偶校验位配置</li>
<li>支持硬件流控制 nCTS 、nRTS</li>
<li>RX 过采样技，过采样技术可区分有效输入数据和噪声，从而用于恢复数据。</li>
<li>小数波特率发生器系统</li>
<li>相关的状态标志以及中断事件</li>
<li>DMA收发</li>
</ul>

        <h2 id="SPI-串行外设接口"   >
          <a href="#SPI-串行外设接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#SPI-串行外设接口" class="headerlink" title="SPI 串行外设接口"></a>SPI 串行外设接口</h2>
      
        <h3 id="常见-SPI-接口特性"   >
          <a href="#常见-SPI-接口特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见-SPI-接口特性" class="headerlink" title="常见 SPI 接口特性"></a>常见 SPI 接口特性</h3>
      <ul>
<li>可用作主模式或者从模式的全双工或者半双工同步通信</li>
<li>可通过硬件或者软件进行 NSS 管理</li>
<li>可设置的时钟极性和相位，可选的发送顺序和数据位数</li>
<li>相关的状态标志以及中断事件</li>
<li>DMA收发</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/05/18/mcu_soc/mcu-gpio/">GPIO</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-05-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-09</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>&#8195;&#8195;GPIO，即通用输入输出端口，是 MCU 必不可少的外设之一，通俗来说，就是 MCU 可以被程序控制的管脚。通过程序控制 GPIO 从而读写引脚上的电平状态。GPIO 不仅用于控制引脚电平，还可以复用为一些通信端口的信号引脚。</p>

        <h2 id="GPIO-电路结构"   >
          <a href="#GPIO-电路结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#GPIO-电路结构" class="headerlink" title="GPIO 电路结构"></a>GPIO 电路结构</h2>
      <p>&#8195;&#8195;下图描述了 STM32F1xx 的 GPIO 内部电路结构，大部分 MCU 的 GPIO 电路结构与此大同小异，部分特殊 IO 结构有所出入。</p>
<p><img src="https://raw.githubusercontent.com/LiangJinlongFX/gallery/main/STM32F1xxGPIO%E7%94%B5%E8%B7%AF.png" alt="STM32F1xxGPIO电路"></p>
<p>&#8195;&#8195;从右往左看，外部引脚进来有一个上下保护二极管，用于避免应电流倒灌等异常造成内部电路损坏。接着为可设置通断的上下拉电阻，具体阻值参考芯片 datasheet。内部分为输入以及输出两大部分，输入输出电路电平处于线与的逻辑，因此在设置输出的电平状态也会反馈到输入部分。输入部分，输入状态寄存器通过一个触发器获取电平数值，部分MCU也可能是直接获取当前引脚电平状态的</p>

        <h2 id="GPIO-模式"   >
          <a href="#GPIO-模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#GPIO-模式" class="headerlink" title="GPIO 模式"></a>GPIO 模式</h2>
      <p>&#8195;&#8195;为适应不同的控制\通信电路，GPIO 通常可配置为多种 I/O 电路模式。</p>

        <h3 id="浮空输入"   >
          <a href="#浮空输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#浮空输入" class="headerlink" title="浮空输入"></a>浮空输入</h3>
      <p>&#8195;&#8195;引脚电平通过施密特触发器后直接保存在输入寄存器里面。输出控制保持断开高阻状态。外部输入时0读出的就是0，外部输入时1读出的就是1，外部没有输入IO处于阻塞读不出电平状态。在读取一段一段的波形，可以清晰的知道什么时候是0信号，什么时候是1信号，什么时候是没有信号的。</p>

        <h3 id="上拉-下拉输入"   >
          <a href="#上拉-下拉输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#上拉-下拉输入" class="headerlink" title="上拉/下拉输入"></a>上拉/下拉输入</h3>
      <p>&#8195;&#8195;与浮空输入类似，但设置了上拉或者下拉电阻，当无输入时，引脚电平取决于下拉或者下拉设置，以明确空闲时的 IO 电平状态。</p>

        <h3 id="模拟输入"   >
          <a href="#模拟输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h3>
      <p>&#8195;&#8195;引脚路径不经过施密特触发器而是直接送到 ADC 外设中，这样保留最原始的电压值，不是转换过后的0和1信号。</p>

        <h3 id="模拟输出"   >
          <a href="#模拟输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#模拟输出" class="headerlink" title="模拟输出"></a>模拟输出</h3>
      <p>&#8195;&#8195;DAC 外设建立的电压直接反馈到外部引脚。</p>

        <h3 id="推挽输出"   >
          <a href="#推挽输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#推挽输出" class="headerlink" title="推挽输出"></a>推挽输出</h3>
      <p>&#8195;&#8195;输出寄存器写入1或者0，如果写入1，P-mos导通，N-mos截止，IO口等价直接连接在VDD上，所以IO口电平是高电平。同理输出寄存器的值为0时，P-mos截止，N-mos导通。IO口直接连接在VSS上，所有IO口电平为低电平。推挽输出可以快速的切换0和1。</p>

        <h3 id="开漏输出"   >
          <a href="#开漏输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#开漏输出" class="headerlink" title="开漏输出"></a>开漏输出</h3>
      <p>&#8195;&#8195;开漏输出与推挽输出唯一的区别就是开漏输出只有一个N-mos管。当输出寄存器的值为0的时候，n-mos导通，IO口直接连接VSS，输出为低电平。当输出寄存器为1的时候，n-mos截止，IO口直接和输出端断开了，处于浮空状态。电平状态不可控制。作为输出的时候一定要加上拉电阻，加上上拉电阻后，输入寄存器为1的时候，n-mos截止截止了，好比IO和输出端断开，这是IO口点压就等于上拉电阻的电压。这样变输出了高电平，如果IO口的高电平，连接到了外设低电平的，就会产生电流，电流不会流到IO口，（N-mos管截止了）直接流到外设。是不是增大了驱动能力了。（IO口的驱动能力有限，不能容忍大电流）。</p>

        <h3 id="复用I-O"   >
          <a href="#复用I-O" class="heading-link"><i class="fas fa-link"></i></a><a href="#复用I-O" class="headerlink" title="复用I/O"></a>复用I/O</h3>
      <p>&#8195;&#8195;复用I/O区别在于起点不一样，复用信号源来源片上外设，同样根据外设通信信号设置为推挽或者开漏。I/O在任一时候只能配置为GPIO或者复用外设中的一种。</p>

        <h2 id="GPIO-电气特性"   >
          <a href="#GPIO-电气特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#GPIO-电气特性" class="headerlink" title="GPIO 电气特性"></a>GPIO 电气特性</h2>
      
        <h3 id="输出速率问题"   >
          <a href="#输出速率问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出速率问题" class="headerlink" title="输出速率问题"></a>输出速率问题</h3>
      <p>在STM32 GPIO应用中，会遇到GPIO输出速率设置问题，这里速度指的是输出驱动电路的响应速度，而不是输出信号的速度，输出信号翻转速度与程序有关，而这里的响应速度影响输入驱动电路的带宽，在高速的I/O翻转速度下应选择尽量大的带宽，即更快的响应速度。芯片内部在I/O口的输出部分安排了多个响应速度不同的输出驱动电路，用户可以根据自己的需要选择合适的驱动电路，通过选择速度来选择不同的输出驱动模块，达到最佳的噪声控制和降低功耗的目的。GPIO的引脚速度跟应用相匹配，速度配置越高，噪声越大，功耗越大。</p>

        <h3 id="5V兼容IO"   >
          <a href="#5V兼容IO" class="heading-link"><i class="fas fa-link"></i></a><a href="#5V兼容IO" class="headerlink" title="5V兼容IO"></a>5V兼容IO</h3>
      <p>针对3.3供电的器件，部分引脚允许承受高电压的输入，对于输出，不能直接用于高电平的IO推挽驱动输出，但允许开漏输出</p>

        <h2 id="GPIO-程序控制"   >
          <a href="#GPIO-程序控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#GPIO-程序控制" class="headerlink" title="GPIO 程序控制"></a>GPIO 程序控制</h2>
      
        <h3 id="读-修改-写问题"   >
          <a href="#读-修改-写问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#读-修改-写问题" class="headerlink" title="读-修改-写问题"></a>读-修改-写问题</h3>
      <p>&#8195;&#8195;此问题出现在51单片机控制GPIO需要注意的，单片机从端口读入数据的通道有两个，一个是从锁存器引入，一个是从输出引脚处引入，分别叫做“读锁存器”和“读引脚”。单片机在进行端口输出时，经常要参考其上一次的输出状态，例如，需要将连接到端口的LED闪烁。编程序时往往需要从输出引脚读前一次的输出状态，将其求反后输出。但如果上次是输出“1”使LED点亮，这时候虽然端口上输出逻辑是“1”，但是由于LED的二极管作用将输出高电平拉至“0”电平（0.7V左右），通过引脚读进来就是“0”而非“1”了。这样，将“0”求反后输出还是“1”，就起不到使灯闪烁的目的了。但是，如果这时读的不是端口而是锁存器的输出端Q，则实现闪烁的功能就正常。上述例子很好地说明了为什么单片机在设置读端口功能后还要设置读锁存器这一功能。</p>

        <h3 id="输入-输出状态问题"   >
          <a href="#输入-输出状态问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入-输出状态问题" class="headerlink" title="输入/输出状态问题"></a>输入/输出状态问题</h3>
      <p>当引脚配置为输入状态时，输出电路一般是断开的，只能作读取I/O操作</p>
<p>当引脚配置为输出状态时，程序可通过输入寄存器获取当前I/O状态</p>
<p>当引脚配置为复用模式时，一般允许程序直接读取输入寄存器获取当前I/O状态，但不能对输出寄存器进行操作以避免干扰外设控制引脚</p>

        <h3 id="GPIO寄存器"   >
          <a href="#GPIO寄存器" class="heading-link"><i class="fas fa-link"></i></a><a href="#GPIO寄存器" class="headerlink" title="GPIO寄存器"></a>GPIO寄存器</h3>
      <ul>
<li>输入数据寄存器</li>
<li>输出数据寄存器</li>
<li>I/O模式设置寄存器</li>
<li>复用功能设置寄存器</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/05/13/mcu_soc/soc-mcu-mpu-cpu-sip/">如何理解soc/mcu/mpu/cpu/sip/模组</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-05-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-08-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="CPU-central-processing-unit"   >
          <a href="#CPU-central-processing-unit" class="heading-link"><i class="fas fa-link"></i></a><a href="#CPU-central-processing-unit" class="headerlink" title="CPU (central processing unit)"></a>CPU (central processing unit)</h2>
      <p>&#8195;&#8195;中央处理器，对于CPU这个名词可以代指很多概念，如硬件线程、内核、多核处理器单元、电路板上的处理器器件等。需要根据具体问题来阐述CPU这个概念的理解。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/321291471/answer/660183713" >如何理解处理器、CPU、多处理器、内核、多核</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="MCU-Microcontroller-Unit"   >
          <a href="#MCU-Microcontroller-Unit" class="heading-link"><i class="fas fa-link"></i></a><a href="#MCU-Microcontroller-Unit" class="headerlink" title="MCU (Microcontroller Unit)"></a>MCU (Microcontroller Unit)</h2>
      <p>&#8195;&#8195;微控制器，也是常说的单片机，其是一般用来完成相关硬件控制任务的简单的计算机系统，将硬件实现比较复杂的状态机流程转换为代码控制的方式。微控制器一般用于如工业控制、家电控制面板等，一般不需要强大的计算处理能力，目前大部分应用下8位机都足矣。</p>
<p>典型的单片系统包括以下组成成分：</p>
<ul>
<li>包含一个或者多个微处理器</li>
<li>存储器</li>
<li>提供时钟信号的震荡源和锁相环电路</li>
<li>外部通信接口</li>
<li>若干功能模块</li>
<li>电源调理电路以及稳压器</li>
</ul>

        <h2 id="MPU-Microprocessor-Unit"   >
          <a href="#MPU-Microprocessor-Unit" class="heading-link"><i class="fas fa-link"></i></a><a href="#MPU-Microprocessor-Unit" class="headerlink" title="MPU (Microprocessor Unit)"></a>MPU (Microprocessor Unit)</h2>
      <p>&#8195;&#8195;微处理器，同样，一般场合也是称他为单片机，在MCU的基础上采用了处理性能更为强大的处理核心、也增加了丰富的外设。目前主流的单片机都是32位，如Cortex-M内核等。一般MPU都可以运行</p>
<p>&#8195;&#8195;下图为主流单片机的架构示意：</p>
<p><img   src="https://pic1.zhimg.com/80/v2-8455f8e91235e6769f30658640245c9d_720w.jpg?source=1940ef5c" style=""  alt="img"></p>

        <h2 id="SOC-System-on-a-Chip"   >
          <a href="#SOC-System-on-a-Chip" class="heading-link"><i class="fas fa-link"></i></a><a href="#SOC-System-on-a-Chip" class="headerlink" title="SOC (System on a Chip)"></a>SOC (System on a Chip)</h2>
      <p>&#8195;&#8195;一般认知的“单片系统”这个术语常被用来指功能更加强大的处理器，目前狭义的SOC与一般单片机的界限在于是否搭载了MMU以及可以运行Windows和Linux的某些版本。单片系统更强的功能要求它具备外部存储芯片，例如有的单片系统配备了闪存。单片系统往往可以连接额外的外部设备。单片系统对半导体器件的集成规模提出了更高的要求。为了更好地执行更复杂的任务，一些单片系统采用了多个处理器核心。<br>&#8195;&#8195;另外，除了运行操作系统，针对专用的领域还集成了专用的IP核，如用于手机设备的SOC一般集成了基带。而用于机顶盒、图像处理等应用的SOC则需要集成图像处理引擎等。</p>

        <h2 id="SiP-System-in-Package"   >
          <a href="#SiP-System-in-Package" class="heading-link"><i class="fas fa-link"></i></a><a href="#SiP-System-in-Package" class="headerlink" title="SiP (System in Package)"></a>SiP (System in Package)</h2>
      <p>&#8195;&#8195;<strong>系统级封装</strong>（System in Package, SiP）为一种集成电路封装的概念，是将一个系统或子系统的全部或大部分电子功能配置在集成型衬底内，而芯片以2D、3D的方式接合到集成型衬底的封装方式。SIP不仅可以组装多个芯片，还可以作为一个专门的处理器、DRAM、闪存与被动组件结合电阻器和电容器、连接器、天线等，全部安装在同一衬底上上。这意味着，一个完整的功能单位可以建在一个多芯片封装，因此，需要添加少量的外部组件，使其工作。</p>
<p><img src="https://pic2.zhimg.com/80/v2-fd0a6a9408546032d9a1b29d241d08b5_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-855849912d26890e48799209fd9a962b_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-2ac1239e5b1824db5b997d959b6bf232_720w.jpg" alt="img"></p>

        <h2 id="模组"   >
          <a href="#模组" class="heading-link"><i class="fas fa-link"></i></a><a href="#模组" class="headerlink" title="模组"></a>模组</h2>
      <p>&#8195;&#8195;模组已经超出集成电路的范围，不再是在硅片衬底上集成。而是在电路板上集成，整体打包后作为一个解决方案，给目标客户使用。</p>
<p><img   src="https://pic1.zhimg.com/80/v2-d6a0a4c1f452595978293ce34817555d_720w.jpg?source=1940ef5c" style=""  alt="img"></p>

        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      <p>&#8195;&#8195;以上几种可以属于计算机系统的范围，其主要是根据集成的复杂度、计算处理能力等因素对其的划分。计算机系统集成不仅限于硅片衬底、也可以是板级的，我们不必太多注重怎么定义，因为其都是一种系统集成复杂度的描述。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/images/author_image.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/LiangJinlongFX" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/Jinlong15071708" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">16</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">1</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Jinlong</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>